- [补码](#补码)
- [异或运算符交换两个变量的值](#异或运算符交换两个变量的值)
- [逻辑右移](#逻辑右移)
- [无符号整型和有符号整型的编码](#无符号整型和有符号整型的编码)
  - [无符号整型编码](#无符号整型编码)
  - [无符号整型编码](#无符号整型编码-1)
- [截断数字](#截断数字)
- [整数运算溢出](#整数运算溢出)
- [浮点数IEEE754标准](#浮点数ieee754标准)

##  补码
计算机中整数以补码的形式存放
    计算一个数的相反数只需要将其取反后`+1`即可
    如`-5 = ~5 + 1` `5 = ~-5 + 1`
需要注意的是，补码是取反后+1，移码是取反后对负数+1，因此移码会有+0和-0，而补码只存在一个0

##  异或运算符交换两个变量的值
使用如下代码可以交换两个变量的值
```C
#include <stdio.h>
void swap(int *v1, int *v2)
{
    (*v1) ^= (*v2) ^= (*v1) ^= (*v2);
}
int main()
{
    int a = 123;
    int b = 456;
    swap(&a, &b);
    printf("a = %d\nb = %d\n", a, b);
    return 0;
}
```
运行结果是将`a`的值和`b`的值进行了交换，但是当传入的参数都是`a`的地址时:
```C
#include <stdio.h>
void swap(int *v1, int *v2)
{
    (*v1) ^= (*v2) ^= (*v1) ^= (*v2);
}
int main()
{
    int a = 123;
    swap(&a, &a);
    printf("a = %d\n", a);
    return 0;
}
```
结果`a`的值变成了`0`，并且这种交换并不能提高程序的运行速率。

##  逻辑右移
*   __逻辑右移__：向右移`n`位，并在左边补`n`个`0`
*   __算术右移__：向右移`n`位，并在左边补`n`个最高位的值

在程序进行位移运算时，__C语言__ 标准并没有明确定义应该使用哪种类型的右移。对于无符号数据右移是逻辑右移，对于有符号数据，几乎所有的编译器都使用算术右移
但是 __java__ 有着明确的定义:`x>>n`使用算术右移，`x>>>n`使用逻辑右移

```C
#include <stdio.h>
int main()
{
    int          a = 0x87654321;
    unsigned int b = 0x87654321;
    a >>= 3;
    b >>= 3;
    printf("a = %x\nb = %x\n", a, b);
    return 0;
}
```
计算结果:`a`=0xf0eca864, `b`=0x10eca864

实际上的位移量是`k%w`得到的(`w`是变量占有的位数，`k`是移动的位数)
比如`int a = 0x1234`, 那么`a >> 3`和`a >> 35`的结果是一样的

##  无符号整型和有符号整型的编码
### 无符号整型编码
    0b0001 = 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 = 1
    0b0101 = 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 5
    0b1011 = 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 11
    0b1111 = 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = 15
### 无符号整型编码
    0b0001 = -0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 =  1
    0b0101 = -0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 =  5
    0b1011 = -1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = -5
    0b1111 = -1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = -1
__在 C 语言中，当有符号数和无符号数进行比较时，有符号数会被转换为无符号数。__


##  截断数字
一个`n`位的数字在折断为一个`k`位的数字时，我们丢弃高`n-k`位，在恢复时符号扩展把高`n-k`位设置为`1`
```C
int     a = 0xabcd; // 43981
short   b = a;      // -21555
int     c = b;      // -21555
```
折断 __无符号整型__ x到k位的结果就相当于计算`x mod 2^k`

##  整数运算溢出
运算结果去除溢出的位数即可

## 浮点数IEEE754标准
在`32`位下，由1位符号位，8位阶码位(__移码__)，23位尾数位(__原码__)组成

在`64`位下，由1位符号位，11位阶码位(__移码__)，52位尾数位(__原码__)组成

尾数位中最高位1不予以存储，阶码-127(64位下-1023)作为指数