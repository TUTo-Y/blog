- [从源文件到可执行文件](#从源文件到可执行文件)
- [数据格式](#数据格式)
- [数据传输](#数据传输)
- [算术和逻辑操作](#算术和逻辑操作)
- [条件码](#条件码)
  - [访问条件码](#访问条件码)
  - [跳转指令及其编码](#跳转指令及其编码)
  - [条件传输指令](#条件传输指令)

# 从源文件到可执行文件

`main.c`->预处理->`main.i`->汇编->`main.s`->编译->`main.o`->链接->`main.out`

# 数据格式

| C语言声明     | 字节数(32位) | 字节数(64位) |
| :------------ | :----------: | :----------: |
| `char`        |      1       |      1       |
| `short`       |      2       |      2       |
| `int`         |      4       |      4       |
| `long`        |      4       |      8       |
| `long long`   |      8       |      8       |
| `void*`       |      4       |      8       |
| `float`       |      4       |      4       |
| `double`      |      8       |      8       |
| `long double` |      12      |      16      |

# 数据传输

| 指令   | 效果                     |
| ------ | ------------------------ |
| movb   | 传送字节                 |
| movw   | 传输字                   |
| movl   | 传输双字                 |
| movsbw | 符号扩展的字节传输到字   |
| movsbl | 符号扩展的字节传输到双字 |
| movswl | 符号扩展的字传输到双字   |
| movzbw | 零扩展的字节传输到字     |
| movzbl | 零扩展的字节传输到双字   |
| movzwl | 零扩展的字传输到双字     |

movs和movz都是将一个较小的数据复制到一个较大的数据位置，高位用符号位扩展(movs)或者零扩展(movz)

# 算术和逻辑操作

| 指令        | 效果       | 描述         |
| :---------- | :--------- | :----------- |
| leal S, D   | D ← &S     | 加载有效地址 |
| INC    D    | D ← D + 1  | 加1          |
| DEC    D    | D ← D - 1  | 减1          |
| NEG    D    | D ← -D     | 取补         |
| NOT    D    | D ← ~D     | 取反         |
| ADD    S, D | D ← D + S  | 加           |
| SUB    S, D | D ← D - S  | 减           |
| IMUL   S, D | D ← D * S  | 乘           |
| XOR    S, D | D ← D ^ S  | 异或         |
| OR     S, D | D ← D \| S | 或           |
| AND    S, D | D ← D & S  | 与           |
| SAL    k, D | D ← D << k | 左移         |
| SHL    k, D | D ← D << k | 左移(同SHL)  |
| SAR    k, D | D ← D >> k | 算术右移     |
| SHR    k, D | D ← D >> k | 逻辑右移     |

# 条件码

用于描述最近的算术或逻辑操作的属性
| 条件码 | 描述1    | 描述2                                                        |
| ------ | -------- | ------------------------------------------------------------ |
| CF     | 进位标志 | 最近的操作使最高位产生了进位，可以用来检测无符号操作数的溢出 |
| ZF     | 零标志   | 最近的操作得出的结果为0                                      |
| SF     | 符号标志 | 最近的操作得到的结果为负数                                   |
| OF     | 溢出标志 | 最近的操作导致一个补码溢出                                   |

CMP和SUB指令行为是一样的，但是CMP不改变目标寄存器的值
TEST和AND指令行为是一样的，但是TEST不改变目标寄存器的值

## 访问条件码

| 指令     | 同义名 | 效果               | 设置条件             |
| -------- | ------ | ------------------ | -------------------- |
| sete   D | setz   | D ← ZF             | 相等/零              |
| setne  D | setnz  | D ← ~ZF            | 不等/非零            |
| sets   D |        | D ← SF             | 负数                 |
| setns  D |        | D ← ~SF            | 非负数               |
| setg   D | setnle | D ← ~(SF^OF) & ~ZF | 大于(有符号>)        |
| setge  D | setnl  | D ← ~(SF^OF)       | 大于等于(有符号>=)   |
| setl   D | setnge | D ← SF^OF          | 小于(有符号<)        |
| setle  D | setng  | D ← (SF^OF) \| ZF  | 小于等于(有符号<=)   |
| seta   D | setnbe | D ← ~CF & ~ZF      | 超过(无符号>)        |
| setae  D | setnb  | D ← ~CF            | 超过或相等(无符号>=) |
| setb   D | setnae | D ← CF             | 低于(无符号<)        |
| setbe  D | setna  | D ← CF \| ZF       | 低于等于(无符号<=)   |

## 跳转指令及其编码

jmp指令是无条件跳转，它可以是直接跳转，也可以是间接跳转。其余所示跳转都是条件跳转，条件跳转只能是直接跳转。

- 跳转指令的编码有几种不同形式，最常用的有两种
1. 将目标指令的地址与紧跟在跳转指令后面的那条指令的地址的差作为编码，这些地址的偏移量可以为1，2或4个字节
2. 给出绝对地址，用四个字节(32位)直接指定目标

|指令|同义名|跳转条件|描述|
|----|----|----|----|
|jmp  Label   |     |1              |直接跳转|
|jmp  *Operand|     |1              |间接跳转|
|je   Label   |jz   |ZF             |相等/零|
|jne  Label   |jnz  |~ZF            |不相等/非零|
|js   Label   |     |SF             |负数|
|jns  Label   |     |~SF            |非负数|
|jg   Label   |jnle |~(SF^OF) & ~ZF |大于(有符号>)|
|jge  Label   |jnl  |~(SF^OF)       |大于或等于(有符号>=)|
|jl   Label   |jnge |SF ^ OF        |小于(有符号<)|
|jle  Label   |jng  |(SF^OF) \| ZF  |小于或等于(有符号<=)|
|ja   Label   |jnbe |~CF & ~ZF      |超过(无符号>)|
|jae  Label   |jnb  |~CF            |超过或相等(无符号>=)|
|jb   Label   |jnae |CF             |低于(无符号<)|
|jbe  Label   |jna  |CF \| ZF       |低于或相等(无符号<=)|

## 条件传输指令

大多数情况下，__数据的条件转移__ 的性能优于 __控制的条件转移__，原因在于，现代处理器使用了 __流水线__ 和 __预测执行__ 技术来提高性能。当执行条件跳转指令时，如果处理器预测错误，那么流水线可能需要被清空并重新填充，这会导致性能损失。而条件数据传输指令不会改变程序的控制流，因此不会导致流水线冲刷，通常可以提供更好的性能。
然而，这并不是绝对的。在某些情况下，例如当条件很少改变或者条件改变的代价很小时，条件跳转可能会更有效。此外，条件数据传输指令通常只能在寄存器之间传输数据，而不能直接访问内存。


